#include <iostream>
#include <string>
#include <cstring>
#include <cassert>
#include <vector>
#include <memory>

void foo(std::string& str) {}
void foo2(std::string&& str) {}
void bar(const std::string& str) {}

void whichValueRef(std::string&) { std::cout << "lvalue ref" << std::endl; }
void whichValueRef(const std::string&) { std::cout << "const lvalue ref" << std::endl; }
void whichValueRef(std::string&&) { std::cout << "rvalue ref" << std::endl; }

// move semantics : move constructor and assignement
// steal internals of a temporary but moving data from one object to another
// should reset internals of origin at the end of the move
class StringWithMove
{
public:
    StringWithMove() : buffer{nullptr}, len{0}
    {
        std::cout << "StringWithMove default constructor" << std::endl;
    }
    // if "StringWithMove() = default;" => core dump at exit when delete str4 (buffer not nullptr)
    // if "StringWithMove() = delete;" => str4 not compile
    StringWithMove(const char* _buffer, size_t _len)  : buffer{new char[_len+1]}, len{_len}
    {
        std::cout << "StringWithMove second constructor" << std::endl;
        strncpy(buffer, _buffer, len+1);
    }
    ~StringWithMove() { if (buffer != nullptr) delete [] buffer; }

    StringWithMove(const StringWithMove& s) : buffer{new char[s.len+1]}, len{s.len}
    {
        std::cout << "StringWithMove copy constructor" << std::endl;
        if (s.buffer != nullptr) strncpy(buffer, s.buffer, len+1);
    }

    // This move constructor has no default version generated by compiler:
    // it was forecast at the first stage for C++11 standard but Scott Meyers highligthed that 
    // is breaking existing code (Aug 2010)
    StringWithMove(StringWithMove&& s) noexcept // comment noexcept for last example (scott)
        : buffer{std::move(s.buffer)}, len{std::move(s.len)}
    {
        std::cout << "StringWithMove move constructor" << std::endl;
        s.buffer = nullptr;
        s.len = 0;
        // to prevent compiler to be able to figure out whether an exception may arise
        if (len == 314) throw int();
    }

    StringWithMove substr(size_t _pos, size_t _len)
    {
        assert(_len > 0 && len > _pos +_len);
        char* _buffer = new char[_len];
        strncpy(_buffer, buffer+_pos, _len);
        return StringWithMove(_buffer, _len);
    }
    StringWithMove substr2(size_t _pos, size_t _len)
    {
        assert(_len > 0 && len > _pos +_len);
        char* _buffer = new char[_len];
        strncpy(_buffer, buffer+_pos, _len);
        return std::move(StringWithMove(_buffer, _len));
    }

    StringWithMove& operator=(const StringWithMove& s)
    {
        if (this != &s)
        {
            std::cout << "StringWithMove copy assignement" << std::endl;
            buffer = new char[s.len+1];
            len = s.len;
            strncpy(buffer, s.buffer, len+1);
        }
        return *this;
    }
    StringWithMove& operator=(StringWithMove&& s) noexcept
    {
        if (this != &s)
        {
            std::cout << "StringWithMove move assignement" << std::endl;
            buffer = s.buffer;
            len = s.len;
            s.buffer = nullptr;
            s.len = 0;
        }
        return *this;
    }

private:
    char* buffer;
    size_t len;
};

template <class T> void swap(T& t1, T& t2)
{
    T temp(t1);
    t1 = t2;
    t2 = temp;
}

template <class T> void swapWithMove(T& t1, T& t2)
{
    T temp(std::move(t1));
    t1 = std::move(t2);
    t2 = std::move(temp);
}

template <typename T>
void universalref(T&&) // deduced parameter type with && is universal ref (otherwise not)
{
    std::cout << "universalref (both rvalue and lvalue)" << std::endl;
}

template <typename T>
void universalref(const T&&)
{
    std::cout << "universalref (both rvalue and lvalue)" << std::endl;
}

template <typename T>
void notuniversalref(std::vector<T>&&) // fully specified type for && (no type deduction)
{
    std::cout << "notuniversalref: rvalue ref" << std::endl;
}

template <typename T>
void notuniversalref(std::vector<T>&) 
{
    std::cout << "notuniversalref: lvalue ref " << std::endl;
}

template<typename T, typename Arg>
std::shared_ptr<T> copy_factory(Arg&& arg)
{
    std::cout << "factory with && param + copy" << std::endl;
    return std::shared_ptr<T>(new T(arg)); // because arg is a lvalue
}

template<typename T, typename Arg>
std::shared_ptr<T> move_factory(Arg&& arg)
{
    std::cout << "factory with && param + move" << std::endl;
    return std::shared_ptr<T>(new T(std::forward<Arg>(arg)));
}

int main()
{
    std::string hello{"hello world!"};
    // foo(hello.substr(0,3)); //=> expect only lvalue (need rvalue ref)
    foo2(hello.substr(0,3));
    bar(hello.substr(0,3));
    std::string& str1 = hello;
    std::string&& str2 = hello.substr(0,3);
    // std::string&& str3 = hello; //=> don't bind lvalue with rvalue ref

    // rvalue become a lvalue once assign to a variable
    foo(str2);
    // foo2(str2); //=> not anymore an rvalue
    bar(str2);

    whichValueRef(hello);
    whichValueRef(str1);
    const std::string& str3 = hello;
    whichValueRef(str3);
    whichValueRef(hello.substr(0,3)); // rvalue ref
    whichValueRef(str2);

    // turn anything to a rvalue with std::move and then bound to a rvalue ref
    std::cout << "\nstd::move..." << std::endl;
    whichValueRef(std::move(hello));
    whichValueRef(std::move(str1));
    whichValueRef(std::move(str2));
    // not really anything & + && => & (collapsing rule see below)
    whichValueRef(std::move(str3)); // stay a lvalue

    // move semantics
    std::cout << "\nmove semantics..." << std::endl;
    StringWithMove str4; //=> default constructor
    StringWithMove str5("hello world!", 12);
    StringWithMove str6(str5);
    std::cout << "rvo : construct temporary and use as is" << std::endl;
    StringWithMove str7(str5.substr(0,3));
    std::cout << "construct temporary, pass it as rvalue and move" << std::endl;
    StringWithMove str8(str5.substr2(0,3));

    // get rid off useless copies
    std::cout << "\nswap..." << std::endl;
    swap(str7, str8);
    swapWithMove(str7, str8);

    // Move operations are an optimization of copy operations, but they are not always cheap
    // Stroustrup recommendation : it is typically a bad idea to have a move operation throw,
    // so declare those noexcept whereever possible
    std::cout << "\nnoexcept (scott meyers' example)..." << std::endl;
    std::cout << "Init vector of 10 elements" << std::endl;
    std::vector<StringWithMove> vs(10);
    std::cout << "vs has size of " << vs.size() << " and capacity of " << vs.capacity() << std::endl;
    std::cout << "Push one more element" << std::endl;
    vs.push_back(StringWithMove("ABC", 3));
//    vs.resize(vs.capacity());
    std::cout << "vs has size of " << vs.size() << " and capacity of " << vs.capacity() << std::endl;
    std::cout << "Push one more element" << std::endl;
    vs.push_back(StringWithMove("DEF", 3));
    std::cout << "vs has size of " << vs.size() << " and capacity of " << vs.capacity() << std::endl;
    // if we comment noexcept (see upper), use copy constructor instead of move constructor

    // Universal references (by Scott Meyers)
    // when we see "&&", we can't say always this is a rvalue reference, 
    // otherwise we'll misread a lot of C++ code.
    // "&&" in a type declaration sometimes means rvalue reference, but sometimes it means
    // either rvalue reference or lvalue reference. Scott Meyers called them universal ref.

    // rule of thumb : if a variable or parameter is declared to have type T&& (or auto&&)
    // for some deduced type T, that variable or parameter is an universal ref.
    std::cout << "\nuniversal ref (useful lie)..." << std::endl;
    std::string&& str9 = hello.substr(0,3); // && means rvalue ref
    auto&& str10 = str9; // universalref: && doesn't mean rvalue because str9 is a name variable then lvalue
    universalref(str9); // same for T&&
    universalref(hello.substr(0,3)); // here it is
    universalref(static_cast<const std::string&&>(hello.substr(0,3)));
    std::vector<std::string>&& v_str = std::vector<std::string>();
    notuniversalref(v_str);
    notuniversalref(std::vector<std::string>());

    // reference collapsing rule (there is no such thing as a ref to a ref) :
    // T& + & => T&
    // T& + && => T&
    // T&& + & => T&
    // T&& + && => T&&

    // based on explanation into Thomas Becker's blog
    std::cout << "\nperfect forwarding..." << std::endl;
    StringWithMove str11("hello world!", 12);
    std::shared_ptr<StringWithMove> pstr 
        = copy_factory<StringWithMove,StringWithMove>(std::move(str11));
    std::shared_ptr<StringWithMove> pstr2 
        = copy_factory<StringWithMove,StringWithMove>(StringWithMove("hello world!", 12));
    std::shared_ptr<StringWithMove> pstr3 
        = move_factory<StringWithMove,StringWithMove>(std::move(str11));
    std::shared_ptr<StringWithMove> pstr4 
        = move_factory<StringWithMove,StringWithMove>(StringWithMove("hello world!", 12));

    return 0;
}
